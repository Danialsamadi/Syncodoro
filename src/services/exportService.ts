import Papa from 'papaparse'
import { createEvent } from 'ics'
import { PomodoroSession } from './database'
import { formatDuration } from '../utils/helpers'

export class ExportService {
  static async exportToCSV(sessions: PomodoroSession[]): Promise<void> {
    const csvData = sessions.map(session => ({
      'Start Time': session.startTime.toISOString(),
      'End Time': session.endTime?.toISOString() || '',
      'Duration (minutes)': Math.round(session.duration / 60),
      'Type': session.type,
      'Completed': session.completed ? 'Yes' : 'No',
      'Tags': session.tags.join(', '),
      'Notes': session.notes || ''
    }))

    const csv = Papa.unparse(csvData)
    this.downloadFile(csv, 'syncodoro-sessions.csv', 'text/csv')
  }

  static async exportToICS(sessions: PomodoroSession[]): Promise<void> {
    const events = sessions
      .filter(session => session.completed && session.endTime)
      .map(session => {
        const startTime = session.startTime
        const endTime = session.endTime!
        
        return createEvent({
          title: `${session.type === 'pomodoro' ? 'Focus Session' : 'Break'} - ${session.tags.join(', ') || 'Untitled'}`,
          description: session.notes || `${session.type} session - ${formatDuration(session.duration)}`,
          start: [
            startTime.getFullYear(),
            startTime.getMonth() + 1,
            startTime.getDate(),
            startTime.getHours(),
            startTime.getMinutes()
          ],
          end: [
            endTime.getFullYear(),
            endTime.getMonth() + 1,
            endTime.getDate(),
            endTime.getHours(),
            endTime.getMinutes()
          ],
          categories: session.tags,
          status: 'CONFIRMED',
          busyStatus: 'BUSY',
          productId: 'syncodoro/ics'
        })
      })

    // Combine all events into a single calendar
    const calendarEvents = events.map(event => event.value).join('')
    const calendar = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:syncodoro/ics
CALSCALE:GREGORIAN
METHOD:PUBLISH
${calendarEvents}END:VCALENDAR`

    this.downloadFile(calendar, 'syncodoro-sessions.ics', 'text/calendar')
  }

  static async exportSessionsReport(sessions: PomodoroSession[]): Promise<void> {
    const completedSessions = sessions.filter(s => s.completed && s.type === 'pomodoro')
    const totalFocusTime = completedSessions.reduce((sum, s) => sum + s.duration, 0)
    
    // Group by tags
    const tagStats: Record<string, { count: number; totalTime: number }> = {}
    completedSessions.forEach(session => {
      session.tags.forEach(tag => {
        if (!tagStats[tag]) {
          tagStats[tag] = { count: 0, totalTime: 0 }
        }
        tagStats[tag].count++
        tagStats[tag].totalTime += session.duration
      })
    })

    // Group by date
    const dailyStats: Record<string, { count: number; totalTime: number }> = {}
    completedSessions.forEach(session => {
      const date = session.startTime.toDateString()
      if (!dailyStats[date]) {
        dailyStats[date] = { count: 0, totalTime: 0 }
      }
      dailyStats[date].count++
      dailyStats[date].totalTime += session.duration
    })

    const report = `# Syncodoro Sessions Report

## Summary
- **Total Sessions**: ${completedSessions.length}
- **Total Focus Time**: ${formatDuration(totalFocusTime)}
- **Average Session Length**: ${formatDuration(totalFocusTime / completedSessions.length || 0)}
- **Date Range**: ${sessions.length > 0 ? `${sessions[0].startTime.toDateString()} - ${sessions[sessions.length - 1].startTime.toDateString()}` : 'No sessions'}

## By Tags
${Object.entries(tagStats)
  .sort(([,a], [,b]) => b.totalTime - a.totalTime)
  .map(([tag, stats]) => `- **${tag}**: ${stats.count} sessions, ${formatDuration(stats.totalTime)}`)
  .join('\n')}

## Daily Breakdown
${Object.entries(dailyStats)
  .sort(([a], [b]) => new Date(b).getTime() - new Date(a).getTime())
  .map(([date, stats]) => `- **${date}**: ${stats.count} sessions, ${formatDuration(stats.totalTime)}`)
  .join('\n')}

## Detailed Sessions
${completedSessions.map((session, index) => `
### Session ${index + 1}
- **Start**: ${session.startTime.toLocaleString()}
- **Duration**: ${formatDuration(session.duration)}
- **Tags**: ${session.tags.join(', ') || 'None'}
- **Notes**: ${session.notes || 'None'}
`).join('\n')}

---
Generated by Syncodoro on ${new Date().toLocaleString()}
`

    this.downloadFile(report, 'syncodoro-report.md', 'text/markdown')
  }

  private static downloadFile(content: string, filename: string, mimeType: string): void {
    const blob = new Blob([content], { type: mimeType })
    const url = URL.createObjectURL(blob)
    
    const link = document.createElement('a')
    link.href = url
    link.download = filename
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    
    URL.revokeObjectURL(url)
  }

  static getExportStats(sessions: PomodoroSession[]): {
    totalSessions: number
    completedSessions: number
    totalFocusTime: number
    dateRange: { start: Date; end: Date } | null
  } {
    const completedSessions = sessions.filter(s => s.completed && s.type === 'pomodoro')
    const totalFocusTime = completedSessions.reduce((sum, s) => sum + s.duration, 0)
    
    let dateRange: { start: Date; end: Date } | null = null
    if (sessions.length > 0) {
      const sortedSessions = [...sessions].sort((a, b) => a.startTime.getTime() - b.startTime.getTime())
      dateRange = {
        start: sortedSessions[0].startTime,
        end: sortedSessions[sortedSessions.length - 1].startTime
      }
    }

    return {
      totalSessions: sessions.length,
      completedSessions: completedSessions.length,
      totalFocusTime,
      dateRange
    }
  }
}
